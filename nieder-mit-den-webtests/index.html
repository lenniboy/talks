<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Nieder mit den Webtests! Wie man Browser-Javascript richtig testet</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Leonard Ehrenfried">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/moon.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>Nieder mit den Webtests!</h1>
          <h3>Wie man Browser JavaScript richtig testet</h3>
          <p>
            <small><a href="http://leonard.io">Leonard Ehrenfried</a> / <a href="http://github.com/lenniboy">@lenniboy</a></small>
          </p>
          <p>
            <small>Freelance Software Consultant</small>
          </p>
        </section>

        <section>
          <h2>Ich gebe es zu</h2>
          <p>Der Titel is ein bisschen reißerisch.</p>
          <p class="fragment">tl;dr: Webtests sind nicht an und für sich schlecht, aber oft das falsche Tool.</p>
        </section>

        <section>
          <h2>Überblick</h2>
          <ol>
            <li>Disclaimer, Begriffsklärung, Einleitung</li>
            <li>Wofür sind Webtests gut?</li>
            <li>Was sind die Probleme von Webtests?</li>
            <li>Unit Tests für JavaScript</li>
            <li>Umsetztung in Backbone und Angular</li>
            <li>Schritt für Schritt zu getestetem JavaScript</li>
          </ol>
        </section>

        <section>
          <h2>Disclaimer</h2>
          <p>Vieles wovon ich spreche bezieht sich auf Webapplikationen und nicht auf Webseiten</p>
          <p class="fragment">Was ist der Untschied? Wenn die Aufgabe der Seite ist Inhalt zu konumieren, dann ist es ein Webseite. Wenn es darum geht mir der Seite zu interagieren, dann wird es eine Webapplikation.</p>
        </section>

        <section>
          <h2>Testing</h2>
          <p>Ist kein neuer Trend</p>
          <p>Ziemlich weitläufig als gute Praxis anerkannt</p>
          <p>TDD hat sich auf Serverseite durchgesetzt</p>
        </section>

        <section>
          <h2>BrowserJS Testing</h2>
          <p>Sehr viel neuer</p>
          <p class="fragment">Für lange Zeit gab es nicht viel JS, das zu testen war</p>
          <p class="fragment">JS wurde für lange Zeit nicht Ernst genommen, aber das hat sich sehr geändert</p>
        </section>

        <section>
          <h2>Was ist ein Webtest</h2>
          <p>Webtests sind die Test, die den gesamten Userablauf inklusive der Interaktion mit dem Browser testen.</p>
          <p>Das bei weitestem beliebteste Tool ist Selenium/Webdriver</p>
        </section>

        <section>
          <h2>Nachteile von Webtests</h2>
            <ul>
              <li>Langsam: Tests werden nicht vor dem Commit ausgeführt</li>
              <li>Wartungsaufwändig: Asynchronität führt zu vielen Problemen</li>
              <li>Sehr grobe Granularität: Unklar was den Test fehlschlagen lassen hat</li>
              <li>Nonlokalität: schwierig ein Szenario unter Test aufzubauen</li>
              <li>Nondeterministisch und flaky: Viele <em>false negatives</em>, Entwickler fangen and fehlgeschlagene Tests zu ignoreren</li>
              <li>Schlechte Debuggability: Man kann nicht durch die Tests steppen, da der Browser unabhängig vom Testrunner ist </li>
              <li class="fragment">Keine Unit Tests, sondern Scenariotests</li>
           </ul>
        </section>

        <section>
          <h2>Kleiner Exkurs: Testpyramide</h2>
          <img style="background: white;" src="img/pyramid.png" alt="test pyramid" />
          <small><a href="http://martinfowler.com/bliki/TestPyramid.html">http://martinfowler.com/bliki/TestPyramid.html</a></small>
          <p>Web tests sind UI Tests!</p>
        </section>

        <section>
          <h2>Wofür sind Webtests gut?</h2>
          <p>Einmal alle Schichten durchzutesten</p>
          <p>Happy path</p>
        </section>
        <section data-background-transition="slide" data-background="#830009">
          <h2>Testbarkeit</h2>
          <p>Server-seitiger code von 1998: wahrscheinlich nicht besonders testbar geschrieben</p>
          <ul>
            <li>Globale Variablen</li>
            <li>Statische Methoden</li>
            <li>Feste Abhängigkeit</li>
          </ul>
        </section>

        <section>
          <h2>Verbesserungen</h2>
          <ul>
            <li>DI</li>
            <li>lokale Variablen</li>
            <li>polymorphism, "ask, don't tell"</li>
            <li><em>Miško Hevery: Seams (Nähte)</em></li>
          </ul>
        </section>

        <section>
          <h2>Problemfälle der JS-Testbarkeit</h2>
          <ul>
            <li>DOM-Manipulation</li>
            <li>AJAX</li>
            <li>Animationen, <code>setTimeout()</code></li>
          </ul>
        </section>

        <section>
          <h2>Probleme: DOM</h2>
          <ul>
            <li>Direkter Zugriff aufs DOM ist Gift für Testbarkeit!</li>
            <li>
              <pre><code data-trim>
$(".datepicker").datePicker();
              </code></pre>
            </li>
          </ul>
        </section>


        <section>
          <h2>Lösungen: DOM</h2>
          <ul>
            <li>Komponenten produzieren nur HTML oder DOM-Knoten</li>

            <li>
              <pre><code data-trim>
var datePicker = new DatePicker();
var rendered = datePicker.render();
$("#date-picker").append(rendered);
              </code></pre>
            </li>
            <li class="fragment">Kompenenten dürfen nur auf ihrem "eigenen" HTML operieren</li>
            <li class="fragment">Bedeutet natürlich, dass serverseitige Templatingsprachen die Testbarkeit radikal verschlechtern</li>
          </ul>
        </section>

        <section>
          <h2>HTML und JS</h2>
          <ul>
            <li>HTML enthält oft Logik</li>
            <li>Wird selten mitgetestet</li>
            <li>HTML-Schnipsel nicht global aus dem DOM holen!</li>
            <li>Als explizite Abhängigkeiten definieren, z.B. mit requireJS</li>
          </ul>
        </section>

        <section>
          <h2>Probleme: AJAX</h2>
          <ul>
            <li>Benötigt laufenden Server, der antworten zurückschickt</li>
            <li>Macht Testsetup komplizierter und -ausführung langsamer</li>
            <li>Ziel sollte sein Tests ohne Server laufen zu lassen</li>
          </ul>
        </section>

        <section>
          <h2>Lösungen: AJAX</h2>
          <ul>
            <li>In server-seitigem Code mit DAO-Schicht gemockt</li>
          </ul>
          <ul class="fragment">
            <li>Globales <code>XMLHttpRequest</code> monkey-patchen</li>
            <li>Oder Mock Http-Service injecten</li>
          </ul>
        </section>

        <section data-background-transition="slide" data-background="#000623" >
          <h2>Exkurs: sinon.js</h2>
            <p>Sehr beliebte Library um HTTP zu mocken</p>

            <pre><code data-trim>
var fakeAjax = function(func) {
  var xhr = sinon.useFakeXMLHttpRequest();
  var requests = [];
  xhr.onCreate = function(xhr){
    requests.push(xhr);
  }
  func(requests);
  xhr.restore();
});
            </code></pre>
        </section>

        <section data-background="#000623" >
          <h2>Anwendung</h2>
            <pre><code data-trim>
fakeAjax(function(requests){
  var customer = new Customer({ id:1234 });
  customer.fetch();
  var req = requests[0];
  req.respond(200, {id : 1234, name: "Horst Kasuppke"});

  expect(customer.get("name")).toBe("Horst Kasuppke");
});
            </code></pre>
          <p>Führt zu einem deterministischen Test ohne implizites Warten</p>
        </section>

        <section>
          <h2>Probleme: Animationen, setTimeout()</h2>
          <ul>
            <li>Animationen arbeiten oft mit <code>setTimeout</code></li>
          </ul>
            <pre><code data-trim>
var callbackCalled = false;
jasmine.Clock.useMock();
setTimeout(function() {
  callbackCalled = true;
}, 100);
jasmine.Clock.tick(101);
expect(callbackCalled).toBe(true);
            </code></pre>
          <ul>
            <li>Tests könnnen ohne implizite Waits ausgeführt werden und bleiben blitzschnell</li>
          </ul>
        </section>

        <section>
          <h2>Fazit bis hierhin</h2>
          <p>JS ist oft höchst asynchron und mit einem zweiten Programm/VM
             sinnvolle Asserts zu schreiben ist extrem wartungsaufwändig</p>
          <p>Um schnelle Unit Tests für Browser JS zu schreiben müssen wir viel
             näher an den Code als es mit Selenium möglich ist</p>
        </section>

        <section>
          <h2>Backbone</h2>
          <ul>
            <li>Sehr frühes, minimalistisches Frontend-MVC Framework</li>
            <li>Gute Wahl für Apps mit niedriger Komplexität und recht wenig Features</li>
            <li>Sehr testbar, da sehr simpel strukturiert</li>
            <li>Muss sich allerdings selbst Disziplin auferlegen</li>
          </ul>
        </section>

        <section>
          <h2>Wie tested man eine Backbone View?</h2>
          <pre><code data-trim>
fakeAjax(function(requests){
  var view = new MainView();
  view.render();
  var req = requests[0];
  req.respond(200, [
    { name: "Guido von Rossum" },
    { name: "Brenda Eich" }]);
  view.$el.find("button").click();
  expect(view.$el.find("ul li").size()).toBe(2);
});
          </code></pre>
        </section>

        <section>
          <h2>Meine Empfehlungen für Libraries</h2>
          <ul>
            <li>Jasmine als Testrunner</li>
            <li>Sinon für HTTP Mocking</li>
            <li>Handlebars für client-side Templating</li>
            <li>Backbone für kleinere Apps</li>
            <li>Angular für komplexere Apps</li>
          </ul>
        </section>
        <section>
          <h1>THE END</h1>
          <h3>Leonard Ehrenfried</h3>
          <h4>Hire me: <a href="http://leonard.io/hire-me/">http://leonard.io/hire-me/</a></h4>
        </section>

        <section>
          <h1>Fragen?</h1>
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none
        backgroundTransion: "slide",

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
        ]
      });

    </script>

  </body>
</html>
